/**
 * TimelineKonvaElement - Simple Config-Based Renderer
 *
 * This is a "dumb renderer" that just applies pre-calculated Konva animation
 * configs generated by the studio view. All complex logic has been moved to
 * the config generator, making this component very simple and maintainable.
 *
 * Architecture:
 * - Studio: Generates complete animation config
 * - Student: Just applies the config to Konva
 */

import React, { useRef, useEffect } from 'react';
import { Text, Circle, Rect, Line, Arrow } from 'react-konva';
import type Konva from 'konva';
import { TimelineEvent } from '../../common/types';

/**
 * Props for TimelineKonvaElement
 */
interface TimelineKonvaElementProps {
  /** Timeline event with pre-calculated Konva config */
  event: TimelineEvent;
}

/**
 * TimelineKonvaElement Component
 *
 * Renders and animates timeline elements using conditional rendering.
 * Component only mounts when element should be visible, unmounts when hidden.
 * Animates on mount, no hide logic needed (unmount handles disappearance).
 */
export const TimelineKonvaElement: React.FC<TimelineKonvaElementProps> = ({
  event,
}) => {
  const nodeRef = useRef<Konva.Shape | Konva.Text>(null);
  const tweenRef = useRef<Konva.Tween | null>(null);

  /**
   * Animate on mount (Option C: Conditional Rendering)
   *
   * Component only mounts when element should be visible.
   * Animates from initialState to targetState on mount.
   * Unmounts when element should be hidden (no hide animation needed).
   */
  useEffect(() => {
    const node = nodeRef.current;
    if (!node || !event.konvaConfig) return;

    const { animation } = event.konvaConfig;

    // Start from initial state
    node.setAttrs(animation.initialState);

    // Create animation to target state
    const tween = new Konva.Tween({
      node: node,
      duration: animation.duration / 1000, // Convert ms to seconds
      easing: Konva.Easings[animation.easing],
      ...animation.targetState,
      onFinish: () => {
        // Pop arrowhead at end for wipe animations
        if (event.elementType === 'arrow' && event.animation === 'wipe') {
          node.to({
            pointerLength: 10,
            pointerWidth: 10,  // Grow width with length
            duration: 0.15, // Quick 150ms pop
            easing: Konva.Easings.BackEaseOut,
          });
        }
      },
    });

    tweenRef.current = tween;
    tween.play();

    // Cleanup on unmount
    return () => {
      if (tweenRef.current) {
        tweenRef.current.destroy();
        tweenRef.current = null;
      }
    };
  }, []); // Only run on mount - no visibility dependency

  // Validate config exists
  if (!event.konvaConfig) {
    console.warn(`Event ${event.id} missing konvaConfig - cannot render`);
    return null;
  }

  const { konvaProps, animation } = event.konvaConfig;

  /**
   * Render element based on type
   *
   * Just spread props - no calculations needed!
   */
  switch (event.elementType) {
    case 'text':
      return (
        <Text
          ref={nodeRef as React.RefObject<Konva.Text>}
          {...konvaProps}
          {...animation.initialState}
          listening={false}
        />
      );

    case 'shape':
      if (event.shapeType === 'circle') {
        return (
          <Circle
            ref={nodeRef as React.RefObject<Konva.Circle>}
            {...konvaProps}
            {...animation.initialState}
            listening={false}
          />
        );
      } else {
        // Rectangle
        return (
          <Rect
            ref={nodeRef as React.RefObject<Konva.Rect>}
            {...konvaProps}
            {...animation.initialState}
            listening={false}
          />
        );
      }

    case 'line':
      return (
        <Line
          ref={nodeRef as React.RefObject<Konva.Line>}
          {...konvaProps}
          {...animation.initialState}
          listening={false}
        />
      );

    case 'arrow':
      return (
        <Arrow
          ref={nodeRef as React.RefObject<Konva.Arrow>}
          {...konvaProps}
          {...animation.initialState}
          listening={false}
        />
      );

    default:
      console.warn(`Unknown element type: ${event.elementType}`);
      return null;
  }
};
