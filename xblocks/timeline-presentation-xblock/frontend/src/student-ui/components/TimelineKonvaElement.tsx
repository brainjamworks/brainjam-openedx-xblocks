/**
 * TimelineKonvaElement - Simple Config-Based Renderer
 *
 * This is a "dumb renderer" that just applies pre-calculated Konva animation
 * configs generated by the studio view. All complex logic has been moved to
 * the config generator, making this component very simple and maintainable.
 *
 * Architecture:
 * - Studio: Generates complete animation config
 * - Student: Just applies the config to Konva
 */

import React, { useRef, useEffect, useMemo } from 'react';
import { Text, Circle, Ring, Rect, Line, Arrow } from 'react-konva';
import type Konva from 'konva';
import { TimelineEvent } from '../../common/types';
import { generateKonvaConfig } from '../../studio-ui/utils/konvaConfigGenerator';

/**
 * Props for TimelineKonvaElement
 */
interface TimelineKonvaElementProps {
  /** Timeline event with pre-calculated Konva config */
  event: TimelineEvent;
  /** Canvas dimensions from editor (for percentage calculations) */
  stageDimensions?: { width: number; height: number };
  /** Scale factor for proportional sizing (fonts, thickness, arrows) */
  sizingScaleFactor?: number;
}

/**
 * TimelineKonvaElement Component
 *
 * Renders and animates timeline elements using conditional rendering.
 * Component only mounts when element should be visible, unmounts when hidden.
 * Animates on mount, no hide logic needed (unmount handles disappearance).
 */
export const TimelineKonvaElement: React.FC<TimelineKonvaElementProps> = ({
  event,
  stageDimensions,
  sizingScaleFactor = 1,
}) => {
  const nodeRef = useRef<Konva.Shape | Konva.Text>(null);
  const tweenRef = useRef<Konva.Tween | null>(null);

  // Generate Konva config at runtime with scale factor
  const konvaConfig = useMemo(() => {
    if (!stageDimensions) {
      console.warn(`Event ${event.id} missing stageDimensions`);
      return null;
    }
    return generateKonvaConfig(event, stageDimensions, sizingScaleFactor);
  }, [event, stageDimensions, sizingScaleFactor]);

  /**
   * Animate on mount (Option C: Conditional Rendering)
   *
   * Component only mounts when element should be visible.
   * Animates from initialState to targetState on mount.
   * Unmounts when element should be hidden (no hide animation needed).
   */
  useEffect(() => {
    const node = nodeRef.current;
    if (!node || !konvaConfig) return;

    const { animation } = konvaConfig;

    // Start from initial state
    node.setAttrs(animation.initialState);

    // Create animation to target state
    const tween = new Konva.Tween({
      node: node,
      duration: animation.duration / 1000, // Convert ms to seconds
      easing: Konva.Easings[animation.easing],
      ...animation.targetState,
      onFinish: () => {
        // Pop arrowhead at end for draw animations
        if (event.elementType === 'arrow' && event.animation === 'draw') {
          // Use scaled pointer values from konvaProps
          const targetPointerLength = konvaProps.pointerLength || 10;
          const targetPointerWidth = konvaProps.pointerWidth || 10;

          node.to({
            pointerLength: targetPointerLength,
            pointerWidth: targetPointerWidth,
            duration: 0.15, // Quick 150ms pop
            easing: Konva.Easings.BackEaseOut,
          });
        }
      },
    });

    tweenRef.current = tween;
    tween.play();

    // Cleanup on unmount
    return () => {
      if (tweenRef.current) {
        tweenRef.current.destroy();
        tweenRef.current = null;
      }
    };
  }, [konvaConfig]); // Re-run if config changes (scale factor updates)

  // Validate config exists
  if (!konvaConfig) {
    return null; // Warning already logged in useMemo
  }

  const { konvaProps, animation } = konvaConfig;

  /**
   * Render element based on type
   *
   * Just spread props - no calculations needed!
   */
  switch (event.elementType) {
    case 'text':
      return (
        <Text
          ref={nodeRef as React.RefObject<Konva.Text>}
          {...konvaProps}
          {...animation.initialState}
          listening={false}
        />
      );

    case 'shape':
      if (event.shapeType === 'circle') {
        return (
          <Circle
            ref={nodeRef as React.RefObject<Konva.Circle>}
            {...konvaProps}
            {...animation.initialState}
            listening={false}
          />
        );
      } else if (event.shapeType === 'ring') {
        // Ring can render as Circle (for draw animation) or Ring (for other animations)
        // Check which properties are present in konvaProps
        if ('radius' in konvaProps && !('innerRadius' in konvaProps)) {
          // Draw animation: Use Circle with stroke (single path)
          return (
            <Circle
              ref={nodeRef as React.RefObject<Konva.Circle>}
              {...konvaProps}
              {...animation.initialState}
              listening={false}
            />
          );
        } else {
          // Other animations: Use Ring (inner+outer radius)
          return (
            <Ring
              ref={nodeRef as React.RefObject<Konva.Ring>}
              {...konvaProps}
              {...animation.initialState}
              listening={false}
            />
          );
        }
      } else {
        // Rectangle
        return (
          <Rect
            ref={nodeRef as React.RefObject<Konva.Rect>}
            {...konvaProps}
            {...animation.initialState}
            listening={false}
          />
        );
      }

    case 'line':
      return (
        <Line
          ref={nodeRef as React.RefObject<Konva.Line>}
          {...konvaProps}
          {...animation.initialState}
          listening={false}
        />
      );

    case 'arrow':
      return (
        <Arrow
          ref={nodeRef as React.RefObject<Konva.Arrow>}
          {...konvaProps}
          {...animation.initialState}
          listening={false}
        />
      );

    default:
      console.warn(`Unknown element type: ${event.elementType}`);
      return null;
  }
};
